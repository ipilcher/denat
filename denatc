#!/usr/bin/python

import ConfigParser
import requests
import pyroute2
import netaddr
import logging
import socket
import string
import errno
import time
import stat
import sys
import re
import os

from logging.handlers import SysLogHandler


###
###	 Intial setup
###

debug = False
foreground = False

for arg in sys.argv[1:]:
	if arg == '-d' or arg == '--debug':
		debug = True
	elif arg == '-f' or arg == '--foreground':
		foreground = True
	else:
		sys.stderr.write('{0}: Unknown option: {1}\n'.format(sys.argv[0], arg))

LOG = logging.getLogger(__name__)
LOG.setLevel(logging.DEBUG if debug else logging.INFO)

if foreground:
	LOG.addHandler(logging.StreamHandler())
else:
	lh = SysLogHandler(address = '/dev/log', facility = SysLogHandler.LOG_DAEMON)
	LOG.addHandler(lh)

# Suppress pyroute2 warning about unreadable /proc/net/psched
pyroute_tcmsg_logger = logging.getLogger('pyroute2.netlink.rtnl.tcmsg.common')
pyroute_tcmsg_logger.addHandler(logging.NullHandler())


###
###	Config file parsing
###

def get_ipv4_gateway():

        with open('/proc/net/route') as fh:

                for line in fh:

                        fields = line.strip().split()
                        if fields[1] != '00000000' or not int(fields[3], 16) & 2:
                                continue

                        return str(netaddr.IPAddress(socket.htonl(int(fields[2], 16))))

                return None


def get_ipv6_gateway():

       with open('/proc/net/ipv6_route') as fh:

                for line in fh:

                        fields = line.strip().split()
                        if fields[0] != '00000000000000000000000000000000' or not int(fields[8], 16) & 2:
                                continue

                        return str(netaddr.IPAddress(int(fields[4], 16)))

                return None


def parse_config():

	cp = ConfigParser.RawConfigParser()
	cp.read(['/etc/denatc/denatc.conf'])

	cfg = {}

	if cp.has_option('firewall', 'host'):
		cfg['host'] = cp.get('firewall', 'host')
	else:
		cfg['host'] = get_ipv4_gateway()
		if cfg['host'] is None:
			cfg['host'] = get_ipv6_gateway()

	cfg['port'] = 9797
	if cp.has_option('firewall', 'port'):
		cfg['port'] = cp.get('firewall', 'port')

	cfg['interface'] = None
	if cp.has_option('firewall', 'interface'):
		cfg['interface'] = cp.get('firewall', 'interface')

	cfg['username'] = cp.get('dns', 'username')
	cfg['password'] = cp.get('dns', 'password')

	if cp.has_option('dns', 'hostname'):
		cfg['hostname'] = cp.get('dns', 'hostname')
	else:
		cfg['hostname'] = socket.getfqdn(socket.gethostname()).partition('.')[2]

	cfg['host_addr'] = netaddr.IPAddress(cp.get('address', 'host'), 6)
	cfg['host_int'] = cp.get('address', 'interface')

	return cfg


###
###	Get public IPs from the firewall
###

def is_public_ip(ip):

        return not ( ip.is_reserved()
                        or ip.is_private()
                        or ip.is_multicast()
                        or ip.is_loopback()
                        or ip.is_link_local()
                        or ip.is_ipv4_mapped()
                        or ip.is_ipv4_compat()  )


def get_firewall_ips(cfg):

	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	try:
		s.connect((cfg['host'], cfg['port']))
		lines = s.recv(1024).splitlines()
	except Exception as e:
		LOG.error(unicode(e))
		return None
	finally:
		s.close()

	public_ips = { 4: None, 6: None, 'prefix': None }

	for line in lines:

		fields = string.split(line)

		if fields[0] == '__PREFIX__' and len(fields) > 1:
			prefix = netaddr.IPNetwork(fields[1])
			if prefix.prefixlen == 56:
				public_ips['prefix'] = prefix
			else:
				LOG.warning('Ignoring prefix: %s', str(prefix))
			continue

		if fields[0] != cfg['interface']:
			continue;

		ip = netaddr.IPAddress(fields[1])
		if not is_public_ip(ip):
			continue

		if public_ips[ip.version] is not None:
			LOG.warning('Ignoring extra public address: %s', ip)
			continue;

		public_ips[ip.version] = ip

	return public_ips


###
###	Update dyn.com DNS - unused
###

def update_dyn_dns(cfg, firewall_ips):

	dns_ips = []
	if firewall_ips[4] is not None:
		dns_ips.append(firewall_ips[4])
	if firewall_ips[6] is not None:
		dns_ips.append(firewall_ips[6])
	if len(dns_ips) == 0:
		LOG.warning('No IP addresses; not updating DNS')
		return

	try:
		req = requests.get('http://members.dyndns.org/v3/update',
				   auth=(cfg['username'], cfg['password']),
				   params={ 'hostname': cfg['hostname'], 'myip': dns_ips })
	except Exception as e:
		LOG.error('DNS update error: %s', unicode(e))
		return

	result = string.split(req.text)[0]

	if req.status_code != 200 or (result != 'good' and result != 'nochg'):
		LOG.error('DNS update error: %s: %s: %s', req.status_code, req.reason, req.text)


###
###	Update Hurricane Electric DNS
###

def update_he_dns_ip(cfg, ip):

	auth = (cfg['hostname'], cfg['password'])

	try:
		req = requests.get('https://dyn.dns.he.net/nic/update', auth=auth,
				   params={ 'hostname': cfg['hostname'], 'myip': ip })
		LOG.info('Updated DNS for %s', ip)
	except Exception as e:
		LOG.error('DNS update error: {0}\n'.format(unicode(e)))
		return
	if req.status_code != 200:
		response = string.split(req.text)[0]
		if response != 'good' and response != 'nochg':
			LOG.error('DNS update error: {0}: {1}: {2}\n'.format(
				  req.status_code, req.reason, req.text))


def update_he_dns(cfg, firewall_ips):

	if len(firewall_ips) == 0:
		LOG.warning('No IP addresses\n')
		return

	if firewall_ips[4] is not None:
		update_he_dns_ip(cfg, auth, firewall_ips[4])
	if firewall_ips[6] is not None:
		update_he_dns_ip(cfg, auth, firewall_ips[6])


###
###	Update public IPv6 address
###

def update_host_addr(cfg, prefix):

	new_addr = prefix.ip | cfg['host_addr']
	addr_present = False

	with pyroute2.IPRoute() as ipr:

		int_idx = ipr.link_lookup(ifname=cfg['host_int'])
		if len(int_idx) == 0:
			LOG.warning('No such interface: %s', cfg['host_int'])
			return
		int_idx = int_idx[0]

		for addr in ipr.get_addr(index=int_idx, family=socket.AF_INET6):
			ip = netaddr.IPAddress(addr.get_attr('IFA_ADDRESS'), 6)
			if ip.is_private():
				LOG.debug('Not removing %s/%s from %s',
					  str(ip), addr['prefixlen'], cfg['host_int'])
				continue
			if ip == new_addr and addr['prefixlen'] == 64:
				LOG.info('%s/64 already present on %s', str(ip), cfg['host_int'])
				addr_present = True
				continue
			ipr.addr('del', index=int_idx, address=str(ip), mask=addr['prefixlen'])
			LOG.info('Removed %s/%s from %s', str(ip), addr['prefixlen'], cfg['host_int'])

		if addr_present:
			return

		ipr.addr('add', index=int_idx, address=str(new_addr), mask=64)
		LOG.info('Added %s/64 to %s', str(new_addr), cfg['host_int'])

		update_he_dns_ip(cfg, new_addr)


###
###	Update Asterisk SIP configuration
###

def update_sip_conf(firewall_ips):

	if firewall_ips[4] is None:
		LOG.warning('No IPV4 address; not updating Asterisk')
		return

	with open('/etc/asterisk/sip.conf', 'r') as fh:
		old = fh.read()

	p = re.compile('^externaddr=.*$', re.MULTILINE)
	new = p.sub('externaddr={0}'.format(firewall_ips[4]), old, count=1)

	try:
		os.remove('/etc/asterisk/sip.conf.new')
	except EnvironmentError as e:
		if e.errno != errno.ENOENT:
			raise

	umask = os.umask(0)
	try:
		fd = os.open('/etc/asterisk/sip.conf.new',
			     os.O_WRONLY | os.O_CREAT | os.O_EXCL,
			     stat.S_IRUSR | stat.S_IWUSR | stat.S_IRGRP | stat.S_IWGRP)
	finally:
		os.umask(umask)

	with os.fdopen(fd, 'w') as fh:
		fh.write(new)

	os.rename('/etc/asterisk/sip.conf.new', '/etc/asterisk/sip.conf')


def reload_sip_conf():

	try:
		s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
		s.connect('/var/run/asterisk/asterisk.ctl')
		s.recv(256)
		s.send('cli quit after sip reload\0')
		s.recv(256)
	finally:
		s.close()


###
###	State file
###

def read_state_file():

	state_ips = { 4: None, 6: None, 'prefix': None }

	try:
		with open('/var/lib/denatc/state', 'r') as fh:
			lines = fh.read().splitlines()
	except EnvironmentError as e:
		if e.errno == errno.ENOENT:
			return state_ips
		else:
			raise

	for line in lines:

		net = netaddr.IPNetwork(line)
		if net.version == 6 and net.prefixlen != 128:
			if state_ips['prefix'] is None:
				state_ips['prefix'] = net
			else:
				LOG.warning('Ignoring extra IPv6 prefix in state file: %s', str(net))
		else:
			if state_ips[net.version] is None:
				state_ips[net.version] = net.ip
			else:
				LOG.warning('Ignoring extra IP address in state file: %s', net.ip)

	return state_ips


def write_state_file(ips):

	try:
		os.remove('/var/lib/denatc/state.new')
	except EnvironmentError as e:
		if e.errno != errno.ENOENT:
			raise

	fd = os.open('/var/lib/denatc/state.new', os.O_WRONLY | os.O_CREAT | os.O_EXCL,
		     stat.S_IRUSR | stat.S_IWUSR)
	try:
		for ip in ips.values():
			if ip is not None:
				os.write(fd, '{0}\n'.format(str(ip)))
	finally:
		os.close(fd)

	os.rename('/var/lib/denatc/state.new', '/var/lib/denatc/state')


###
###	Do something!
###

try:

	cfg = parse_config()
	state_ips = read_state_file()
	host_addr_unset = True

	while True:

		public_ips = get_firewall_ips(cfg)

		if public_ips is not None:

			if host_addr_unset or public_ips['prefix'] != state_ips['prefix']:
				update_host_addr(cfg, public_ips['prefix'])
				host_addr_unset = False

			if public_ips[4] != state_ips[4]:
				update_sip_conf(public_ips)
				reload_sip_conf()
				update_he_dns_ip(cfg, public_ips[4])

			if public_ips != state_ips:

				LOG.info('Public IP(s) have changed')
				LOG.info('... old: %s', state_ips)
				LOG.info('... new: %s', public_ips)

				write_state_file(public_ips)
				state_ips = public_ips

		time.sleep(60)

except Exception as e:

	LOG.critical(unicode(e), exc_info=1)
